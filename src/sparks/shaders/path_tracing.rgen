#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
// clang-format off
#include "ray_payload.glsl"
#include "uniform_objects.glsl"
#include "material.glsl"
#include "constants.glsl"
// clang-format on

layout(binding = 0) uniform accelerationStructureEXT scene;
layout(binding = 1, rgba32f) uniform image2D accumulation_color;
layout(binding = 2, r32f) uniform image2D accumulation_number;
layout(binding = 3) uniform global_uniform_object {
  GlobalUniformObject guo;
};
layout(binding = 4) readonly buffer entity_array {
  EntityUniformObject entity_objects[];
};
layout(binding = 5) readonly buffer material_array {
  Material materials[];
};
layout(binding = 6) readonly buffer object_info_array {
  ObjectInfo object_infos[];
};
layout(binding = 7) readonly buffer vertex_array {
  float vertices[];
};
layout(binding = 8) readonly buffer index_array {
  uint indices[];
};

layout(binding = 9) readonly buffer light_source_array {
  int light_sources[]; // this will save all light sources
};

layout(binding = 10) uniform sampler2D[] texture_samplers;

layout(location = 0) rayPayloadEXT RayPayload ray_payload;

// clang-format off
#include "vertex.glsl"
#include "hit_record.glsl"
#include "random.glsl"
// clang-format on

vec3 SampleEnvmap(vec3 direction) {
  float x = guo.envmap_offset;
  float y = acos(direction.y) * INV_PI;
  if (length(vec2(direction.x, direction.y)) > 1e-4) {
    x += atan(direction.x, -direction.z);
  }
  x *= INV_PI * 0.5;
  return texture(texture_samplers[guo.envmap_id], vec2(x, y))
      .xyz;  // textures_[envmap_id_].Sample();
}

HitRecord hit_record, hit_record_0;
void TraceRay(vec3 origin, vec3 direction) {
  float tmin = 1e-3;
  float tmax = 1e4;

  ray_payload.t = -1.0;
  ray_payload.barycentric = vec3(0.0);
  ray_payload.object_id = 0;
  ray_payload.primitive_id = 0;
  ray_payload.object_to_world = mat4x3(1.0);

  traceRayEXT(scene, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin,
              direction, tmax, 0);
  hit_record = GetHitRecord(ray_payload, origin, direction);
}

void TraceRay_0(vec3 origin, vec3 direction) {
  float tmin = 1e-3;
  float tmax = 1e4;

  ray_payload.t = -1.0;
  ray_payload.barycentric = vec3(0.0);
  ray_payload.object_id = 0;
  ray_payload.primitive_id = 0;
  ray_payload.object_to_world = mat4x3(1.0);

  traceRayEXT(scene, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin,
              direction, tmax, 0);
  hit_record_0 = GetHitRecord(ray_payload, origin, direction);
}


vec3 SampleRay(vec3 origin, vec3 direction) {
  if (guo.sample_algo == 1) { // Cosine-weighted + Sampling the Light
    bool light_sampled = false;
    #define RATE (1.0 - 1.0/guo.num_bounces)
    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);
    for (int b = 0; b < guo.num_bounces; b++) {
      TraceRay(origin, direction); 
      if (ray_payload.t == -1.0) {
        radiance += throughput * SampleEnvmap(direction);
        break;
      } else {

        Material material = materials[hit_record.hit_entity_id];
        if(dot(hit_record.normal, direction) > 0.0f) {
          hit_record.normal = -hit_record.normal;
        }

        // sample the light: 
        if(material.material_type == MATERIAL_TYPE_LAMBERTIAN) {
          int n_lights = int(light_sources[0]);
          int r = int(fract(RandomFloat()) * n_lights) + 1;
          int face_cnt = int(fract(RandomFloat()) * light_sources[2*r+1]);
          int obj = light_sources[2 * r];
          int faceid = int(fract(RandomFloat()) * face_cnt);
          vec3 v1, v2, v3;
          ObjectInfo obj_info = object_infos[obj];
          Vertex nd0 = GetVertex(obj_info.vertex_offset + indices[obj_info.index_offset + face_cnt * 3 + 0]),
                 nd1 = GetVertex(obj_info.vertex_offset + indices[obj_info.index_offset + face_cnt * 3 + 1]),
                 nd2 = GetVertex(obj_info.vertex_offset + indices[obj_info.index_offset + face_cnt * 3 + 2]);
          vec3 d = vec3(RandomFloat() + 1e-4, RandomFloat() + 1e-4, RandomFloat() + 1e-4);
          d /= d.x + d.y + d.z;
          vec3 pt = d.x * nd0.position + d.y * nd1.position + d.z * nd2.position;
          vec3 N = cross(nd1.position - nd0.position, nd2.position - nd0.position);
          float S = length(N);
          N = normalize(N);
          vec3 Origin = hit_record.position;
          vec3 wi = normalize(pt - hit_record.position);
          if(dot(wi, N) > 0) {
            N = -N;
          }
          TraceRay_0(Origin, wi);
          if(ray_payload.t < 0.0f) {
            
          } else {
            Material light_m = materials[hit_record_0.hit_entity_id];
            if(length(hit_record_0.position - pt)  < 1e-3 && light_m.material_type == MATERIAL_TYPE_EMISSION) {
              vec3 radiance_dir = light_m.emission * light_m.emission_strength / (2 * PI)
                          * (material.albedo_color / PI) // diffusive
                          * dot(normalize(hit_record.normal), wi) // cosine
                          * dot(N, -wi) // cosine
                          / pow(length(hit_record_0.position - Origin),2) // length
                          * n_lights * S * light_sources[1];
              radiance += throughput * vec3(texture(texture_samplers[material.albedo_texture_id],hit_record.tex_coord)) * radiance_dir;
            }
          }
          
        }


        if (material.material_type == MATERIAL_TYPE_EMISSION) {
          if(!light_sampled) 
            radiance += throughput * material.emission * material.emission_strength;
          break;
        } else if (material.material_type == MATERIAL_TYPE_LAMBERTIAN) {
          hit_record.normal = normalize(hit_record.normal);
          // float phi = RandomFloat() * PI;
          // float rho = RandomFloat() * 2 * PI;
            // // std::cerr << RRR(rd) << std::endl;
          vec3 wi = RandomOnSphere();
          wi = normalize(wi);
          if(dot(hit_record.normal, wi) < 0.0f) {
            wi = -wi;
          }
          vec3 dirx = normalize(wi - dot(wi, hit_record.normal) * hit_record.normal);
          vec3 diry = cross(hit_record.normal, dirx);
          float rr = abs(RandomFloat());
          float rr2 = RandomFloat() * 2 * PI;
          float cosine = sqrt(1.0f - rr);
          float sine = sqrt(rr);
          wi = sine * cos(rr2) * dirx + sine * sin(rr2) * diry + cosine * hit_record.normal;
          wi = normalize(wi);
          
          // we get true wi until now. (Cosine-weighted)
          float pdf = 2.0 * sine * cosine / (PI);
          // this is calculate shading
          throughput *= cosine * (material.albedo_color / PI) * vec3(texture(texture_samplers[material.albedo_texture_id],hit_record.tex_coord)) / pdf;
          // this is calculate shading
          // throughput *= dot(wi, hit_record.normal) * (material.albedo_color / PI) * vec3(texture(texture_samplers[material.albedo_texture_id],hit_record.tex_coord)) * (2.0f * PI);
          origin = hit_record.position;
          direction = wi;
        } else if (material.material_type == MATERIAL_TYPE_SPECULAR) {
          if(dot(hit_record.normal, direction) > 0.0f) {
            hit_record.normal = -hit_record.normal;
          }
          hit_record.normal = normalize(hit_record.normal);
          float phi = RandomFloat() * PI;
          float rho = RandomFloat() * 2.0f * PI;
            // // std::cerr << RRR(rd) << std::endl;
          vec3 wi = direction - 2.0f * hit_record.normal;
          if(dot(hit_record.normal, wi) < 0.0f) {
            wi = -wi;
          }
          // this is calculate shading
          origin = hit_record.position;
          direction = wi;
        } 
        else {
          throughput *= material.albedo_color *
                        vec3(texture(texture_samplers[material.albedo_texture_id],
                                    hit_record.tex_coord));
          origin = hit_record.position;
          direction = guo.envmap_light_direction;
          radiance += throughput * guo.envmap_minor_color;
          throughput *= max(dot(direction, hit_record.normal), 0.0) * 2.0;
          TraceRay(origin, direction);
          if (ray_payload.t < 0.0f) {
            radiance += throughput * guo.envmap_major_color;
          }
          break;
        }
        if(material.material_type == MATERIAL_TYPE_LAMBERTIAN) {
          light_sampled = true;
        }
      }
    }
    return radiance;
  }
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);
  for (int b = 0; b < guo.num_bounces; b++) {
    TraceRay(origin, direction); 
    if (ray_payload.t == -1.0) {
      radiance += throughput * SampleEnvmap(direction);
      break;
    } else {
      Material material = materials[hit_record.hit_entity_id];
      if (material.material_type == MATERIAL_TYPE_EMISSION) {
        radiance += throughput * material.emission * material.emission_strength;
        break;
      } else if (material.material_type == MATERIAL_TYPE_LAMBERTIAN) {
        if(dot(hit_record.normal, direction) > 0.0f) {
          hit_record.normal = -hit_record.normal;
        }
        hit_record.normal = normalize(hit_record.normal);
        float phi = RandomFloat() * PI;
        float rho = RandomFloat() * 2 * PI;
          // // std::cerr << RRR(rd) << std::endl;
        vec3 wi = vec3 (
          sin(rho) * cos(phi),
          cos(rho) * cos(phi),
          sin(phi)
        );
        wi = normalize(wi);
        if(dot(hit_record.normal, wi) < 0.0f) {
          wi = -wi;
        }
        // this is calculate shading
        throughput *= dot(wi, hit_record.normal) * (material.albedo_color / PI) * vec3(texture(texture_samplers[material.albedo_texture_id],hit_record.tex_coord)) * (2.0f * PI);
        origin = hit_record.position;
        direction = wi;
      } else if (material.material_type == MATERIAL_TYPE_SPECULAR) {
        if(dot(hit_record.normal, direction) > 0.0f) {
          hit_record.normal = -hit_record.normal;
        }
        hit_record.normal = normalize(hit_record.normal);
        float phi = RandomFloat() * PI;
        float rho = RandomFloat() * 2.0f * PI;
          // // std::cerr << RRR(rd) << std::endl;
        vec3 wi = direction - 2.0f * hit_record.normal;
        if(dot(hit_record.normal, wi) < 0.0f) {
          wi = -wi;
        }
        // this is calculate shading
        origin = hit_record.position;
        direction = wi;
      } 
      else {
        throughput *= material.albedo_color *
                      vec3(texture(texture_samplers[material.albedo_texture_id],
                                   hit_record.tex_coord));
        origin = hit_record.position;
        direction = guo.envmap_light_direction;
        radiance += throughput * guo.envmap_minor_color;
        throughput *= max(dot(direction, hit_record.normal), 0.0) * 2.0;
        TraceRay(origin, direction);
        if (ray_payload.t < 0.0f) {
          radiance += throughput * guo.envmap_major_color;
        }
        break;
      }
    }
  }
  return radiance;
}

void main() {
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2 d = inUV * 2.0 - 1.0;
  mat4 camera_to_world = inverse(guo.camera);
  mat4 screen_to_camera = inverse(guo.projection);
  for (int i = 0; i < guo.num_samples; i++) {
    InitRandomSeed(uint(pixelCenter.x), uint(pixelCenter.y),
                   guo.accumulated_sample + i);
    vec4 origin = camera_to_world * vec4(0, 0, 0, 1);
    vec4 target = screen_to_camera * vec4(d.x, d.y, 1, 1);
    vec4 direction = camera_to_world * vec4(normalize(target.xyz), 0);

    imageStore(accumulation_color, ivec2(gl_LaunchIDEXT.xy),
               imageLoad(accumulation_color, ivec2(gl_LaunchIDEXT.xy)) +
                   vec4(SampleRay(origin.xyz, direction.xyz), 1.0));
    imageStore(accumulation_number, ivec2(gl_LaunchIDEXT.xy),
               imageLoad(accumulation_number, ivec2(gl_LaunchIDEXT.xy)) + 1.0);
  }
}
