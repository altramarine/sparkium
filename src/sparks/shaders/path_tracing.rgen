#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
// clang-format off
#include "ray_payload.glsl"
#include "uniform_objects.glsl"
#include "material.glsl"
#include "constants.glsl"
// clang-format on

layout(binding = 0) uniform accelerationStructureEXT scene;
layout(binding = 1, rgba32f) uniform image2D accumulation_color;
layout(binding = 2, r32f) uniform image2D accumulation_number;
layout(binding = 3) uniform global_uniform_object {
  GlobalUniformObject guo;
};
layout(binding = 4) readonly buffer entity_array {
  EntityUniformObject entity_objects[];
};
layout(binding = 5) readonly buffer material_array {
  Material materials[];
};
layout(binding = 6) readonly buffer object_info_array {
  ObjectInfo object_infos[];
};
layout(binding = 7) readonly buffer vertex_array {
  float vertices[];
};
layout(binding = 8) readonly buffer index_array {
  uint indices[];
};

layout(binding = 9) readonly buffer light_source_array {
  int light_sources[]; // this will save all light sources
};

layout(binding = 10) uniform sampler2D[] texture_samplers;

layout(location = 0) rayPayloadEXT RayPayload ray_payload;

// clang-format off
#include "vertex.glsl"
#include "hit_record.glsl"
#include "random.glsl"
// clang-format on

vec3 SampleEnvmap(vec3 direction) {
  float x = guo.envmap_offset;
  float y = acos(direction.y) * INV_PI;
  if (length(vec2(direction.x, direction.y)) > 1e-4) {
    x += atan(direction.x, -direction.z);
  }
  x *= INV_PI * 0.5;
  return texture(texture_samplers[guo.envmap_id], vec2(x, y))
      .xyz;  // textures_[envmap_id_].Sample();
}

HitRecord hit_record, hit_record_0;
void TraceRay(vec3 origin, vec3 direction) {
  float tmin = 1e-3;
  float tmax = 1e4;

  ray_payload.t = -1.0;
  ray_payload.barycentric = vec3(0.0);
  ray_payload.object_id = 0;
  ray_payload.primitive_id = 0;
  ray_payload.object_to_world = mat4x3(1.0);

  traceRayEXT(scene, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin,
              direction, tmax, 0);
  hit_record = GetHitRecord(ray_payload, origin, direction);
}

void TraceRay_0(vec3 origin, vec3 direction) {
  float tmin = 1e-3;
  float tmax = 1e4;

  ray_payload.t = -1.0;
  ray_payload.barycentric = vec3(0.0);
  ray_payload.object_id = 0;
  ray_payload.primitive_id = 0;
  ray_payload.object_to_world = mat4x3(1.0);

  traceRayEXT(scene, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin,
              direction, tmax, 0);
  hit_record_0 = GetHitRecord(ray_payload, origin, direction);
}
float get_pdf_ratio(vec3 origin, vec3 wi /* should be normalized */, vec3 normal, vec3 wo, int idx) {
  HitRecord hit_record_p = hit_record_0;
  RayPayload rpl = ray_payload;
  TraceRay_0(origin, wi);
  Material material = materials[hit_record_0.hit_entity_id];
  float s[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  if (material.material_type == MATERIAL_TYPE_EMISSION) {
    vec3 N = hit_record_0.normal;
    if(dot(wi, N) > 0.0f) {
      N = -N;
    }
    float S = length(hit_record_0.geometry_normal) / 2;
    // vec3 L_direct = throughput * (material.albedo_color / PI) * vec3(texture(texture_samplers[material.albedo_texture_id],hit_record.tex_coord)) * radiance_dir;
    float sampling_the_light_pdf = dot(N, -wi) // cosine
                * S / pow(length(hit_record_0.position - origin),2)
                * light_sources[0] * object_infos[hit_record_0.hit_entity_id].num_faces;
    if(sampling_the_light_pdf != 0.0f) {
      sampling_the_light_pdf = 1.0f / sampling_the_light_pdf;
    }
    s[0] = sampling_the_light_pdf;
  }
  hit_record_0 = hit_record_p;
  rpl = ray_payload;
  s[1] = dot(normal, wi) / PI;
  // return 1 - idx;
  // return 1 / 2;
  // return idx == 1 ? 0.2 : 0.8;
  return s[idx] * s[idx] / (s[0] * s[0] + s[1] * s[1]);
}

vec3 SampleRay(vec3 origin, vec3 direction) {
  if (guo.sample_algo == 1) { // Cosine-weighted + Sampling the Light
    float light_sampled = 1.0f; // if = 1.0f, then we are using Sampling the Light
    #define RATE (1.0 - 1.0/guo.num_bounces)
    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);
    light_sampled = 1.0f;
    do {
      // vec3 L_direct = vec3(0.0f);
      TraceRay(origin, direction); 
      if (ray_payload.t == -1.0) {
        radiance += throughput * SampleEnvmap(direction);
        break;
      } else {
        vec3 safe_direction = direction;
        Material material = materials[hit_record.hit_entity_id];
        vec3 hit_record_normal = hit_record.normal;

        if(dot(hit_record.normal, direction) > 0.0f) {
          hit_record.normal = -hit_record.normal;
        }

        // SEARCH_TARGET::: sample the light: 
        if(material.material_type == MATERIAL_TYPE_LAMBERTIAN) {
          int n_lights = int(light_sources[0]);
          int r = RandomInt(n_lights) + 1;
          int face_cnt = light_sources[2 * r + 1];
          int obj = light_sources[2 * r];
          int faceid = RandomInt(face_cnt);
          // vec3 v1, v2, v3;
          ObjectInfo obj_info = object_infos[obj];
          Vertex nd0 = GetVertex(obj_info.vertex_offset + indices[obj_info.index_offset + faceid * 3 + 0]),
                 nd1 = GetVertex(obj_info.vertex_offset + indices[obj_info.index_offset + faceid * 3 + 1]),
                 nd2 = GetVertex(obj_info.vertex_offset + indices[obj_info.index_offset + faceid * 3 + 2]);
          vec3 d = vec3(RandomFloat(), RandomFloat(), RandomFloat());
          while(d.x + d.y + d.z == 0.0f) {
            vec3 d = vec3(RandomFloat(), RandomFloat(), RandomFloat());
          }
          d /= d.x + d.y + d.z;
          d /= d.x + d.y + d.z;
          vec3 pt = d.x * nd0.position + d.y * nd1.position + d.z * nd2.position;
          vec3 N = cross(nd1.position - nd0.position, nd2.position - nd0.position);
          float S = length(N) / 2;
          N = normalize(N);
          vec3 Origin = hit_record.position;
          vec3 wi = normalize(pt - hit_record.position);
          if(dot(wi, N) > 0) {
            N = -N;
          }
          TraceRay_0(Origin, wi);
          if(ray_payload.t < 0.0f) {
            
          } else {
            Material light_m = materials[hit_record_0.hit_entity_id];
            if(length(hit_record_0.position - pt)  < 1e-3 && light_m.material_type == MATERIAL_TYPE_EMISSION) {
              vec3 radiance_dir = light_m.emission * light_m.emission_strength
                          * max(0.0f, dot(normalize(hit_record.normal), wi)) // cosine
                          * dot(N, -wi) // cosine
                          * S / pow(length(hit_record_0.position - Origin),2)
                          * n_lights * face_cnt;
              vec3 L_direct = throughput * (material.albedo_color / PI) * vec3(texture(texture_samplers[material.albedo_texture_id],hit_record.tex_coord)) * radiance_dir;
              float sampling_the_light_pdf = dot(N, -wi) // cosine
                          * S / pow(length(hit_record_0.position - Origin),2)
                          * n_lights * face_cnt;
              if(sampling_the_light_pdf != 0.0f) {
                sampling_the_light_pdf = 1.0f / sampling_the_light_pdf;
              }
              // if(sampling_the_light_pdf != 0.0f)
              radiance += L_direct * get_pdf_ratio(Origin, wi, hit_record.normal, -direction, 0);
            }
          }
        }


        if (material.material_type == MATERIAL_TYPE_EMISSION) {
          // if(!light_sampled) 
          // radiance += throughput * material.emission * material.emission_strength;
          radiance += light_sampled * throughput * material.emission * material.emission_strength;
          break;
        } else if (material.material_type == MATERIAL_TYPE_LAMBERTIAN) {
          hit_record.normal = normalize(hit_record.normal);
          // float phi = RandomFloat() * PI;
          // float rho = RandomFloat() * 2 * PI;
            // // std::cerr << RRR(rd) << std::endl;
          vec3 wi = RandomOnSphere();
          wi = normalize(wi);
          if(dot(hit_record.normal, wi) < 0.0f) {
            wi = -wi;
          }
          vec3 dirx = normalize(wi - dot(wi, hit_record.normal) * hit_record.normal);
          vec3 diry = cross(hit_record.normal, dirx);
          float rr = RandomFloat();
          float rr2 = RandomFloat() * 2 * PI;
          float cosine = sqrt(1.0f - rr);
          float sine = sqrt(rr);
          wi = sine * cos(rr2) * dirx + sine * sin(rr2) * diry + cosine * hit_record.normal;
          // wi = normalize(wi);
          
          // we get true wi until now. (Cosine-weighted)
          float pdf = /* 2.0f * sine * cosine */1.0f * cosine / (PI);
          // float pdf = 1.0 / (2.0 * PI);
          // this is calculate shading
          throughput *= dot(wi, hit_record.normal) * (material.albedo_color / PI) * vec3(texture(texture_samplers[material.albedo_texture_id],hit_record.tex_coord)) / pdf;
          // this is calculate shading
          // throughput *= dot(wi, hit_record.normal) * (material.albedo_color / PI) * vec3(texture(texture_samplers[material.albedo_texture_id],hit_record.tex_coord)) * (2.0f * PI);
          origin = hit_record.position;
          direction = wi;

          light_sampled = get_pdf_ratio(origin, direction, hit_record.normal, -safe_direction, 1);
        } else if (material.material_type == MATERIAL_TYPE_SPECULAR) {
          if(dot(hit_record.normal, direction) > 0.0f) {
            hit_record.normal = -hit_record.normal;
          }
          hit_record.normal = normalize(hit_record.normal);
          float phi = RandomFloat() * PI;
          float rho = RandomFloat() * 2.0f * PI;
            // // std::cerr << RRR(rd) << std::endl;
          vec3 wi = direction - 2.0f * dot(direction, hit_record.normal) * hit_record.normal;
          if(dot(hit_record.normal, wi) < 0.0f) {
            wi = -wi;
          }
          // this is calculate shading
          origin = hit_record.position;
          direction = wi;

          // light_sampled = get_pdf_ratio(origin, direction, hit_record.normal, -direction, 1);
        } else if (material.material_type == MATERIAL_TYPE_TRANSMISSIVE) {
          hit_record.normal = hit_record_normal;
          vec3 median = -dot(direction, hit_record.normal) * hit_record.normal;
          vec3 proj_x = normalize(direction + median);
          vec3 proj_y = hit_record.normal; 
          // theta: 初始角度，phi: 穿过后角度
          float cos_theta = dot(hit_record.normal, direction);
          float sin_theta = sqrt(1-cos_theta*cos_theta);
          float sin_phi, cos_phi;
          float eta = material.transmissive_rate;
          if (cos_theta < 0) {
            proj_y = -proj_y;
            cos_theta = -cos_theta;
          } else{
            eta = 1.0 / eta;
          }
          sin_phi = eta * sin_theta;
          cos_phi = sqrt(1-sin_phi*sin_phi);
          origin = hit_record.position;
          direction = cos_phi * proj_y + sin_phi * proj_x;
        } else {
          throughput *= material.albedo_color *
                        vec3(texture(texture_samplers[material.albedo_texture_id],
                                    hit_record.tex_coord));
          origin = hit_record.position;
          direction = guo.envmap_light_direction;
          radiance += throughput * guo.envmap_minor_color;
          throughput *= max(dot(direction, hit_record.normal), 0.0) * 2.0;
          TraceRay(origin, direction);
          if (ray_payload.t < 0.0f) {
            radiance += throughput * guo.envmap_major_color;
          }
          break;
        }
        if(material.material_type == MATERIAL_TYPE_LAMBERTIAN) {
          // light_sampled = get_pdf_ratio(origin, direction, hit_record.normal, -safe_direction, 1);
        } else {
          light_sampled = 1.0f;
        }
      }
      throughput /= RATE; // if didn't break, we have (Rate) prob to survive.
    } while(RandomFloat() < RATE);
    return radiance;
  }
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);
  for (int b = 0; b < guo.num_bounces; b++) {
    TraceRay(origin, direction); 
    if (ray_payload.t == -1.0) {
      radiance += throughput * SampleEnvmap(direction);
      break;
    } else {
      Material material = materials[hit_record.hit_entity_id];
      if (material.material_type == MATERIAL_TYPE_EMISSION) {
        radiance += throughput * material.emission * material.emission_strength;
        break;
      } else if (material.material_type == MATERIAL_TYPE_LAMBERTIAN) {
        if(dot(hit_record.normal, direction) > 0.0f) {
          hit_record.normal = -hit_record.normal;
        }
        hit_record.normal = normalize(hit_record.normal);
        float phi = RandomFloat() * PI;
        float rho = RandomFloat() * 2 * PI;
          // // std::cerr << RRR(rd) << std::endl;
        vec3 wi = vec3 (
          sin(rho) * cos(phi),
          cos(rho) * cos(phi),
          sin(phi)
        );
        wi = normalize(wi);
        if(dot(hit_record.normal, wi) < 0.0f) {
          wi = -wi;
        }
        // this is calculate shading
        throughput *= dot(wi, hit_record.normal) * (material.albedo_color / PI) * vec3(texture(texture_samplers[material.albedo_texture_id],hit_record.tex_coord)) * (2.0f * PI);
        origin = hit_record.position;
        direction = wi;
      } else if (material.material_type == MATERIAL_TYPE_SPECULAR) {
        if(dot(hit_record.normal, direction) > 0.0f) {
          hit_record.normal = -hit_record.normal;
        }
        hit_record.normal = normalize(hit_record.normal);
        float phi = RandomFloat() * PI;
        float rho = RandomFloat() * 2.0f * PI;
          // // std::cerr << RRR(rd) << std::endl;
        vec3 wi = direction - 2.0f * hit_record.normal;
        if(dot(hit_record.normal, wi) < 0.0f) {
          wi = -wi;
        }
        // this is calculate shading
        origin = hit_record.position;
        direction = wi;
      } 
      else {
        throughput *= material.albedo_color *
                      vec3(texture(texture_samplers[material.albedo_texture_id],
                                   hit_record.tex_coord));
        origin = hit_record.position;
        direction = guo.envmap_light_direction;
        radiance += throughput * guo.envmap_minor_color;
        throughput *= max(dot(direction, hit_record.normal), 0.0) * 2.0;
        TraceRay(origin, direction);
        if (ray_payload.t < 0.0f) {
          radiance += throughput * guo.envmap_major_color;
        }
        break;
      }
    }
  }
  return radiance;
}

void main() {
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2 d = inUV * 2.0 - 1.0;
  mat4 camera_to_world = inverse(guo.camera);
  mat4 screen_to_camera = inverse(guo.projection);
  for (int i = 0; i < guo.num_samples; i++) {
    InitRandomSeed(uint(pixelCenter.x), uint(pixelCenter.y),
                   guo.accumulated_sample + i);
    vec4 origin = camera_to_world * vec4(0, 0, 0, 1);
    vec4 target = screen_to_camera * vec4(d.x, d.y, 1, 1);
    vec4 direction = camera_to_world * vec4(normalize(target.xyz), 0);

    imageStore(accumulation_color, ivec2(gl_LaunchIDEXT.xy),
               imageLoad(accumulation_color, ivec2(gl_LaunchIDEXT.xy)) +
                   vec4(SampleRay(origin.xyz, direction.xyz), 1.0));
    imageStore(accumulation_number, ivec2(gl_LaunchIDEXT.xy),
               imageLoad(accumulation_number, ivec2(gl_LaunchIDEXT.xy)) + 1.0);
  }
}
